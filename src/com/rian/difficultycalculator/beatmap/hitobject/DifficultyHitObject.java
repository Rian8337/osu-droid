package com.rian.difficultycalculator.beatmap.hitobject;

import com.rian.difficultycalculator.beatmap.hitobject.sliderobject.SliderHitObject;
import com.rian.difficultycalculator.beatmap.hitobject.sliderobject.SliderRepeat;
import com.rian.difficultycalculator.math.MathUtils;
import com.rian.difficultycalculator.math.Precision;
import com.rian.difficultycalculator.math.Vector2;
import com.rian.difficultycalculator.utils.GameMode;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Represents a hit object with additional information for difficulty calculation.
 */
public class DifficultyHitObject {
    /**
     * The underlying hit object.
     */
    public final HitObject object;

    /**
     * The index of this hit object in the list of all hit objects.
     * <br><br>
     * This is one less than the actual index of the hit object in the beatmap.
     */
    public int index;

    /**
     * The preempt time of the hit object.
     */
    public float baseTimePreempt;

    /**
     * Adjusted preempt time of the hit object, taking speed multiplier into account.
     */
    public float timePreempt;

    /**
     * The fade in time of the hit object.
     */
    public double timeFadeIn = 400;

    /**
     * The aim strain generated by the hit object if sliders are considered.
     */
    public double aimStrainWithSliders;

    /**
     * The aim strain generated by the hit object if sliders are not considered.
     */
    public double aimStrainWithoutSliders;

    /**
     * The tap strain generated by the hit object.
     */
    public double tapStrain;

    /**
     * The tap strain generated by the hit object if <code>strainTime</code> isn't modified by
     * OD.
     * <br><br>
     * This is used in three-finger detection.
     */
    public double originalTapStrain;

    /**
     * The rhythm multiplier generated by the hit object. This is used to alter tap strain.
     */
    public double rhythmMultiplier;

    /**
     * The rhythm strain generated by the hit object.
     */
    public double rhythmStrain;

    /**
     * The flashlight strain generated by the hit object if sliders are considered.
     */
    public double flashlightStrainWithSliders;

    /**
     * The flashlight strain generated by the hit object if sliders are not considered.
     */
    public double flashlightStrainWithoutSliders;

    /**
     * The visual strain generated by the hit object if sliders are considered.
     */
    public double visualStrainWithSliders;

    /**
     * The visual strain generated by the hit object if sliders are not considered.
     */
    public double visualStrainWithoutSliders;

    /**
     * The normalized distance from the "lazy" end position of the previous hit object to the start position of this hit object.
     * <br><br>
     * The "lazy" end position is the position at which the cursor ends up if the previous hit object is followed with as minimal movement as possible (i.e. on the edge of slider follow circles).
     */
    public double lazyJumpDistance;

    /**
     * The normalized shortest distance to consider for a jump between the previous hit object and this hit object.
     * <br><br>
     * This is bounded from above by <code>lazyJumpDistance</code>, and is smaller than the former if a more natural path is able to be taken through the previous hit object.
     * <br><br>
     * Suppose a linear slider - circle pattern. Following the slider lazily (see: <code>lazyJumpDistance</code>) will result in underestimating the true end position of the slider as being closer towards the start position.
     * As a result, <code>lazyJumpDistance</code> overestimates the jump distance because the player is able to take a more natural path by following through the slider to its end,
     * such that the jump is felt as only starting from the slider's true end position.
     * <br><br>
     * Now consider a slider - circle pattern where the circle is stacked along the path inside the slider.
     * In this case, the lazy end position correctly estimates the true end position of the slider and provides the more natural movement path.
     */
    public double minimumJumpDistance;

    /**
     * The time taken to travel through <code>minimumJumpDistance</code>, with a minimum value of 25ms.
     */
    public double minimumJumpTime;

    /**
     * The normalized distance between the start and end position of this hit object.
     */
    public double travelDistance;

    /**
     * The time taken to travel through <code>travelDistance</code>, with a minimum value of 25ms for sliders.
     */
    public double travelTime;

    /**
     * Angle the player has to take to hit this hit object.
     * <br><br>
     * Calculated as the angle between the circles (current-2, current-1, current).
     * <br><br>
     * Will be <code>NaN</code> if the hit object does not form an angle.
     */
    public double angle = Double.NaN;

    /**
     * The amount of milliseconds elapsed between this hit object and the last hit object.
     */
    public double deltaTime;

    /**
     * The amount of milliseconds elapsed since the start time of the previous hit object, with a minimum of 25ms.
     */
    public double strainTime;

    /**
     * Adjusted start time of the hit object, taking speed multiplier into account.
     */
    public double startTime;

    /**
     * Adjusted end time of the hit object, taking speed multiplier into account.
     */
    public double endTime;

    /**
     * The note density of the hit object.
     */
    public double noteDensity = 1;

    /**
     * The overlapping factor of the hit object.
     * <br><br>
     * This is used to scale visual skill.
     */
    public double overlappingFactor;

    /**
     * Adjusted velocity of the hit object, taking speed multiplier into account.
     */
    public double velocity;

    /**
     * Other hit objects in the beatmap, including this hit object.
     */
    private final ArrayList<DifficultyHitObject> hitObjects;

    /**
     * A distance by which all distances should be scaled in order to assume a uniform circle size.
     */
    private static final int normalizedRadius = 50;
    private static final int minDeltaTime = 25;

    private final float assumedSliderRadius = normalizedRadius * 1.8f;

    private final HitObject lastObject;
    private final HitObject lastLastObject;

    /**
     * @param index The index of the underlying hit object.
     * @param hitObjects All hit objects in the processed beatmap.
     * @param difficultyHitObjects All difficulty hit objects in the processed beatmap.
     * @param mode The game mode being calculated.
     * @param clockRate The clock rate being calculated.
     * @param timePreempt The preempt time of the hit object.
     * @param isForceAR Whether force AR is used.
     */
    public DifficultyHitObject(int index, List<HitObject> hitObjects,
                               ArrayList<DifficultyHitObject> difficultyHitObjects, GameMode mode,
                               double clockRate, float timePreempt, boolean isForceAR) {
        this.index = index - 1;
        this.object = hitObjects.get(index);
        this.hitObjects = difficultyHitObjects;
        baseTimePreempt = timePreempt;
        this.timePreempt = timePreempt;

        if (!isForceAR) {
            this.timePreempt /= clockRate;
        }

        lastObject = hitObjects.get(index - 1);
        lastLastObject = index > 1 ? hitObjects.get(index - 2) : null;

        deltaTime = (object.startTime - lastObject.getStartTime()) / clockRate;
        startTime = object.startTime / clockRate;

        if (object instanceof HitObjectWithDuration) {
            endTime = ((HitObjectWithDuration) object).endTime / clockRate;
        } else {
            endTime = startTime;
        }

        // Capped to 25ms to prevent difficulty calculation breaking from simultaneous objects.
        strainTime = Math.max(deltaTime, minDeltaTime);

        setDistances(mode, clockRate);
        setVisuals(mode, clockRate, hitObjects);
    }

    /**
     * Gets the difficulty hit object at a specific index with respect to the current
     * difficulty hit object's index.
     * <br><br>
     * Will return <code>null</code> if the index is out of range.
     *
     * @param backwardsIndex The index to move backwards for.
     * @return The difficulty hit object at the index with respect to the current
     * difficulty hit object's index, <code>null</code> if the index is out of range.
     */
    public DifficultyHitObject previous(int backwardsIndex) {
        try {
            return hitObjects.get(index - (backwardsIndex + 1));
        } catch (IndexOutOfBoundsException ignored) {
            return null;
        }
    }

    /**
     * Gets the difficulty hit object at a specific index with respect to the current
     * difficulty hit object's index.
     * <br><br>
     * Will return <code>null</code> if the index is out of range.
     *
     * @param forwardsIndex The index to move forwards for.
     * @return The difficulty hit object at the index with respect to the current
     * difficulty hit object's index, <code>null</code> if the index is out of range.
     */
    public DifficultyHitObject next(int forwardsIndex) {
        try {
            return hitObjects.get(index + forwardsIndex + 1);
        } catch (IndexOutOfBoundsException ignored) {
            return null;
        }
    }

    /**
     * Calculates the opacity of the hit object at a given time.
     *
     * @param time The time to calculate the hit object's opacity at.
     * @param isHidden Whether Hidden mod is used.
     * @param mode The game mode to calculate for.
     * @return The opacity of the hit object at the given time.
     */
    public double opacityAt(double time, boolean isHidden, GameMode mode) {
        if (time > object.startTime) {
            // Consider a hit object as being invisible when its start time is passed.
            // In reality the hit object will be visible beyond its start time up until its hittable window has passed,
            // but this is an approximation and such a case is unlikely to be hit where this function is used.
            return 0;
        }

        double fadeInStartTime = object.startTime - baseTimePreempt;
        double fadeInDuration = timeFadeIn;

        double nonHiddenOpacity = MathUtils.clamp((time - fadeInStartTime) / fadeInDuration, 0, 1);

        if (isHidden) {
            double fadeOutStartTime = fadeInStartTime + fadeInDuration;
            double fadeOutDuration = baseTimePreempt * (mode == GameMode.rimu ? 0.35 : 0.3);

            return Math.min(nonHiddenOpacity, 1 - MathUtils.clamp((time - fadeOutStartTime) / fadeOutDuration, 0, 1));
        }

        return nonHiddenOpacity;
    }

    /**
     * Determines whether this hit object is considered overlapping with the hit object before it.
     * <br><br>
     * Keep in mind that "overlapping" in this case is overlapping to the point where both hit objects
     * can be hit with just a single tap in osu!droid.
     *
     * @param considerDistance Whether to consider the distance between both hit objects.
     * @return Whether the hit object is considered overlapping.
     */
    public boolean isOverlapping(boolean considerDistance) {
        if (object instanceof Spinner) {
            return false;
        }

        DifficultyHitObject previous = previous(0);

        if (previous == null || previous.object instanceof Spinner) {
            return false;
        }

        if (deltaTime >= 5) {
            return false;
        }

        if (considerDistance) {
            Vector2 endPosition = object.getStackedPosition(GameMode.rimu);

            double distance;

            if (previous.object instanceof Slider) {
                distance = previous.object
                        .getStackedEndPosition(GameMode.rimu)
                        .getDistance(endPosition);
            } else {
                distance = previous.object
                        .getStackedPosition(GameMode.rimu)
                        .getDistance(endPosition);
            }

            if (previous.object instanceof Slider && ((Slider) previous.object).lazyEndPosition != null) {
                Slider slider = (Slider) previous.object;
                distance = Math.min(
                        distance,
                        slider.lazyEndPosition.getDistance(endPosition)
                );
            }

            return distance <= 2 * object.getRadius(GameMode.rimu);
        }

        return true;
    }

    private void setDistances(GameMode mode, double clockRate) {
        if (object instanceof Slider) {
            Slider slider = (Slider) object;
            velocity = slider.velocity * clockRate;
            computeSliderCursorPosition(slider, mode);

            travelDistance = slider.lazyTravelDistance;

            // Bonus for repeat sliders until a better per nested object strain system can be achieved.
            if (mode == GameMode.rimu) {
                travelDistance *= Math.pow(1 + (slider.repeatCount - 1) / 4d, 1 / 4d);
            } else {
                travelDistance *= Math.pow(1 + (slider.repeatCount - 1) / 2.5, 1 / 2.5);
            }

            travelTime = Math.max(slider.lazyTravelTime / clockRate, minDeltaTime);
        }

        // We don't need to calculate either angle or distance when one of the last->curr objects
        // is a spinner or there is no object before the current object.
        if (object instanceof Spinner || lastObject == null || lastObject instanceof Spinner) {
            return;
        }

        double scalingFactor = getScalingFactor(mode);
        Vector2 lastCursorPosition = getEndCursorPosition(lastObject, mode);

        lazyJumpDistance = object
                .getStackedPosition(mode)
                .subtract(lastCursorPosition)
                .scale(scalingFactor)
                .getLength();
        minimumJumpTime = strainTime;
        minimumJumpDistance = lazyJumpDistance;

        if (lastObject instanceof Slider) {
            minimumJumpTime = Math.max(strainTime - ((Slider) lastObject).lazyTravelTime / clockRate, minDeltaTime);

            // There are two types of slider-to-object patterns to consider in order to better approximate the real movement a player will take to jump between the hit objects.
            //
            // 1. The anti-flow pattern, where players cut the slider short in order to move to the next hit object.
            //
            //      <======o==>  ← slider
            //             |     ← most natural jump path
            //             o     ← a follow-up hit circle
            //
            // In this case the most natural jump path is approximated by LazyJumpDistance.
            //
            // 2. The flow pattern, where players follow through the slider to its visual extent into the next hit object.
            //
            //      <======o==>---o
            //                  ↑
            //        most natural jump path
            //
            // In this case the most natural jump path is better approximated by a new distance called "tailJumpDistance" - the distance between the slider's tail and the next hit object.
            //
            // Thus, the player is assumed to jump the minimum of these two distances in all cases.
            double tailJumpDistance = ((Slider) lastObject).tail
                        .getStackedPosition(mode)
                        .subtract(object.getStackedPosition(mode))
                        .getLength() * scalingFactor;

            float maximumSliderRadius = normalizedRadius * (mode == GameMode.rimu ? 2f : 2.4f);
            minimumJumpDistance = Math.max(0, Math.min(lazyJumpDistance - (maximumSliderRadius - assumedSliderRadius), tailJumpDistance - maximumSliderRadius));
        }

        if (lastLastObject != null && !(lastLastObject instanceof Spinner)) {
            Vector2 lastLastCursorPosition = getEndCursorPosition(lastLastObject, mode);
            Vector2 v1 = lastLastCursorPosition.subtract(lastObject.getStackedPosition(mode));
            Vector2 v2 = object.getStackedPosition(mode).subtract(lastCursorPosition);
            double dot = v1.dot(v2);
            double det = v1.x * v2.y - v1.y * v2.x;

            angle = Math.abs(Math.atan2(det, dot));
        }
    }

    private void setVisuals(GameMode mode, double clockRate, List<HitObject> hitObjects) {
        // We'll have two visible object lists. The first list contains objects before the current object starts
        // in a reversed order, while the second array contains objects after the current object ends.
        // For overlapping factor, we also need to consider previous visible objects.
        ArrayList<HitObject> prevVisibleObjects = new ArrayList<>();
        ArrayList<HitObject> nextVisibleObjects = new ArrayList<>();

        double endTime = object.startTime;
        if (object instanceof HitObjectWithDuration) {
            endTime = ((HitObjectWithDuration) object).endTime;
        }

        for (int i = index + 2; i < hitObjects.size(); ++i) {
            HitObject currentObject = hitObjects.get(i);

            if (currentObject instanceof Spinner) {
                continue;
            }

            if (currentObject.startTime > endTime + baseTimePreempt) {
                break;
            }

            nextVisibleObjects.add(currentObject);
        }

        for (int i = Math.min(index + 2, hitObjects.size() - 1); i >= 0; --i) {
            HitObject currentObject = hitObjects.get(i);

            if (currentObject instanceof Spinner) {
                continue;
            }

            if (currentObject.startTime >= object.startTime) {
                continue;
            }

            if (currentObject.startTime < object.startTime - baseTimePreempt) {
                break;
            }

            prevVisibleObjects.add(currentObject);
        }

        for (HitObject currentObject : prevVisibleObjects) {
            double distance = object.getStackedPosition(mode).getDistance(currentObject.getStackedEndPosition(mode));
            double deltaTime = object.startTime;

            if (currentObject instanceof HitObjectWithDuration) {
                deltaTime -= ((HitObjectWithDuration) currentObject).endTime;
            } else {
                deltaTime -= currentObject.startTime;
            }

            deltaTime /= clockRate;
            applyToOverlappingFactor(mode, distance, deltaTime);
        }

        for (HitObject currentObject : nextVisibleObjects) {
            double distance = currentObject.getStackedPosition(mode).getDistance(object.getStackedEndPosition(mode));
            double deltaTime = currentObject.startTime;

            if (object instanceof HitObjectWithDuration) {
                deltaTime -= ((HitObjectWithDuration) object).endTime;
            } else {
                deltaTime -= object.startTime;
            }

            if (deltaTime >= 0) {
                noteDensity += 1 - deltaTime / baseTimePreempt;
            }

            deltaTime /= clockRate;
            applyToOverlappingFactor(mode, distance, deltaTime);
        }
    }

    private void computeSliderCursorPosition(Slider slider, GameMode mode) {
        if (slider.lazyEndPosition != null) {
            return;
        }

        // rimu! doesn't have a legacy slider tail. Since beatmap parser defaults slider tail
        // to legacy slider tail, it needs to be changed to real slider tail first.
        if (mode == GameMode.rimu) {
            slider.tail.startTime += Slider.legacyLastTickOffset;

            slider.nestedHitObjects.sort(Comparator.comparingDouble(a -> a.startTime));

            // Stop here if the slider has too short duration due to float number limitation.
            // Incredibly close start and end time fluctuates travel distance and lazy
            // end position heavily, which we do not want to happen.
            //
            // In the real game, this shouldn't happen. Perhaps we need to re-investigate this
            // in the future.
            if (Precision.almostEqualsNumber(slider.startTime, slider.endTime)) {
                return;
            }
        }

        slider.lazyTravelTime = slider.nestedHitObjects.get(slider.nestedHitObjects.size() - 1).startTime - slider.startTime;

        double endTimeMin = slider.lazyTravelTime / slider.spanDuration;
        if (endTimeMin % 2 >= 1) {
            endTimeMin = 1 - endTimeMin % 1;
        } else {
            endTimeMin %= 1;
        }

        // Temporary lazy end position until a real result can be derived.
        slider.lazyEndPosition = slider.getStackedPosition(mode).add(slider.path.positionAt(endTimeMin));

        Vector2 currentCursorPosition = slider.getStackedPosition(mode);
        double scalingFactor = normalizedRadius / slider.getRadius(mode);

        for (int i = 1; i < slider.nestedHitObjects.size(); ++i) {
            SliderHitObject currentMovementObject = slider.nestedHitObjects.get(i);

            Vector2 currentMovement = currentMovementObject
                    .getStackedPosition(mode)
                    .subtract(currentCursorPosition);
            double currentMovementLength = scalingFactor * currentMovement.getLength();

            // The amount of movement required so that the cursor position needs to be updated.
            double requiredMovement = assumedSliderRadius;

            if (i == slider.nestedHitObjects.size() - 1) {
                // The end of a slider has special aim rules due to the relaxed time constraint on position.
                // There is both a lazy end position as well as the actual end slider position. We assume the player takes the simpler movement.
                // For sliders that are circular, the lazy end position may actually be farther away than the sliders' true end.
                // This code is designed to prevent buffing situations where lazy end is actually a less efficient movement.
                Vector2 lazyMovement = slider.lazyEndPosition.subtract(currentCursorPosition);

                if (lazyMovement.getLength() < currentMovement.getLength()) {
                    currentMovement = lazyMovement;
                }

                currentMovementLength = scalingFactor * currentMovement.getLength();
            } else if (currentMovementObject instanceof SliderRepeat) {
                // For a slider repeat, assume a tighter movement threshold to better assess repeat sliders.
                requiredMovement = normalizedRadius;
            }

            if (currentMovementLength > requiredMovement) {
                // This finds the positional delta from the required radius and the current position,
                // and updates the currentCursorPosition accordingly, as well as rewarding distance.
                currentCursorPosition = currentCursorPosition.add(currentMovement.scale((float) ((currentMovementLength - requiredMovement) / currentMovementLength)));
                currentMovementLength *= (currentMovementLength - requiredMovement) / currentMovementLength;
                slider.lazyTravelDistance += (float) currentMovementLength;
            }

            if (i == slider.nestedHitObjects.size() - 1) {
                slider.lazyEndPosition = currentCursorPosition;
            }
        }
    }

    private float getScalingFactor(GameMode mode) {
        // We will scale distances by this factor, so we can assume a uniform CircleSize among beatmaps.
        float radius = (float) object.getRadius(mode);
        float scalingFactor = normalizedRadius / radius;

        // High circle size (small CS) bonus
        switch (mode) {
            case rimu:
                if (radius < 70) {
                    scalingFactor *= 1 + Math.pow((70 - radius) / 50, 2);
                }
                break;
            case standard:
                if (radius < 30) {
                    scalingFactor *= 1 + Math.min(30 - radius, 5) / 50;
                }
                break;
        }

        return scalingFactor;
    }

    private Vector2 getEndCursorPosition(HitObject object, GameMode mode) {
        Vector2 pos = object.getStackedPosition(mode);

        if (object instanceof Slider) {
            Slider slider = (Slider) object;
            computeSliderCursorPosition(slider, mode);
            pos = slider.lazyEndPosition != null ? slider.lazyEndPosition : pos;
        }

        return pos;
    }

    private void applyToOverlappingFactor(GameMode mode, double distance, double deltaTime) {
        // Penalize objects that are too close to the object in both distance
        // and delta time to prevent stream maps from being overweight.
        overlappingFactor +=
                Math.max(0, 1 - distance / (3 * object.getRadius(mode))) *
                (7.5 / (1 + Math.exp(0.15 * (Math.max(deltaTime, minDeltaTime) - 75))));
    }
}
